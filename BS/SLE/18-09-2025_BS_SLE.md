## Donnerstag, 18-09-2025_BS_SLE

### Schalenmodell (Schichtenmodell des Betriebssystems)

Das **Schalenmodell** ist ein vereinfachtes Modell, das zeigt, wie ein Betriebssystem in **Schichten (layers)** aufgebaut ist. Jede Schicht baut auf der darunterliegenden auf und bietet der darüberliegenden neue Funktionen. Dadurch entsteht eine klare Trennung von Aufgaben – ähnlich wie bei einer **Zwiebel mit mehreren Schalen**.

---

#### 1. Hardware
- **Definition**: Alle physischen Teile des Computers – Prozessor (CPU), Arbeitsspeicher (RAM), Festplatten/SSDs, Netzwerkkarten, Grafikkarten, Tastatur, Monitor usw.  
- **Wichtig**: Hardware allein „kann nichts“, sie braucht Steuerung durch Software.  

---

#### 2. HAL (Hardware Abstraction Layer)
- **Definition**: Eine Zwischenschicht, die die Hardware von der Software „abstrahiert“.  
- **Funktion**: Versteckt die Unterschiede zwischen verschiedenen Hardware-Typen.  
  - Beispiel: Ob deine Festplatte von Samsung oder WD ist, merkt dein Betriebssystem dank der HAL kaum.  
- **Vorteil**: Programmierer müssen nicht jedes Mal die genaue Hardware kennen – sie programmieren nur gegen diese vereinheitlichte Schicht.

---

#### 3. Kernel
- **Definition**: Der **Kern** des Betriebssystems, die wichtigste Schicht.  
- **Aufgaben**:
  - **Verwaltung von Prozessen** (Programme starten, stoppen, zeitlich steuern).  
  - **Speicherverwaltung** (welches Programm darf welchen Teil des RAMs nutzen).  
  - **Gerätesteuerung** (Ansprechen von Treibern, also Software, die die Hardware nutzt).  
  - **Dateiverwaltung** (Zugriff auf Daten auf Festplatten/SSDs).  
- **Bild**: Der Kernel ist wie der **Dirigent eines Orchesters** – er selbst macht keine Musik, sorgt aber dafür, dass alles im richtigen Moment zusammenspielt.

---

#### 4. Shell
- **Definition**: Die Schnittstelle zwischen Benutzer und Betriebssystem.  
- **Arten**:
  - **Command Line Interface (CLI)**: Texteingabe, z. B. Bash unter Linux, PowerShell unter Windows.  
  - **Graphical User Interface (GUI)**: Klickbare Oberfläche, z. B. Windows-Desktop oder Linux GNOME.  
- **Funktion**: Übersetzt Benutzerbefehle in etwas, das der Kernel versteht.  

---

#### 5. Programme
- **Definition**: Anwendungen, die der Benutzer startet und nutzt.  
  - Beispiele: Browser (Chrome, Firefox), Textverarbeitung (Word), Spiele, Datenbanksoftware.  
- **Abhängigkeit**: Sie können nur laufen, weil die unteren Schichten (Shell, Kernel, HAL, Hardware) existieren.  

---

### Bildliche Vorstellung
- **Zwiebelprinzip**: Jede Schale schützt die darunterliegende und baut darauf auf.  
- **Reihenfolge von innen nach außen**:  
  - Innen: Hardware  
  - Dann: HAL  
  - Kernel  
  - Shell  
  - Außen: Programme (sichtbar für den Benutzer)  

---

### Prüfungstipps
- Wenn nach **Kernel-Aufgaben** gefragt wird → Prozesse, Speicher, Geräte, Dateien.  
- Unterschied **Shell vs. Kernel** → Kernel macht die Arbeit, Shell vermittelt zwischen Mensch und Kernel.  
- HAL merken als „Adapter“: macht Hardware einheitlich nutzbar.  
---
## Schichtenmodell – Windows

### Diagramm

```
+-------------------------+
|     Programme           |
|     Bibliotheken        |
+-------------------------+
|          API            |
+-------------------------+
|   Systemschnittstelle   |
+-------------------------+
| Prozess-/Ressourcen-    |
|     Management          |
+-------------------------+
|  Dateisystem   Treiber  |
+-------------------------+
|          HAL            |
+-------------------------+
|        Hardware         |
|  (Geräte, CPU, Speicher)|
+-------------------------+
```
---

### Erläuterungen

- **User Modus**  
  - Voneinander abgegrenzte Speicherbereiche  
  - Programme & Bibliotheken laufen hier  

- **Kernel Modus**  
  - Kernelmodus-Treiber **nicht** voneinander abgegrenzt  
  - Enthält zentrale Komponenten wie `Ntoskrnl.exe`  

- **HAL (Hardware Abstraction Layer)**  
  - Vermittelt zwischen Hardware und Kernel  
---
## Monolithischer Kernel

### Definition
Ein **monolithischer Kernel** integriert alle wichtigen Funktionen des Betriebssystems direkt in einem einzigen Kernel-Block.  
Dazu gehören:
- **Speicher- und Prozessverwaltung**
- **Interprozesskommunikation**
- **Treiber für Hardware**

---

### Vorteile
- Reduzierter Zeit- und Rechenaufwand (schneller, da alles direkt integriert ist)  
- Betriebssystem ist **unabhängig von Anwendungen**  

---

### Nachteile
- Funktionen sind schwerer austauschbar  
- Änderungen erfordern oft das **Neukompilieren des gesamten Kernels**  

---

### Beispiel
- **GNU-LINUX**
---
## Monolithischer Kernel – Schichtenmodell

### Diagramm

```
+---------------------------+
|      Anwendungen          |
+---------------------------+
|        VFS, Systemaufrufe |
+---------------------------+
|        IPC, Dateisystem   |
+---------------------------+
|   Scheduler, Virtual Mem. |
+---------------------------+
| Geräte-Treiber, Dispatcher|
+---------------------------+
|          Hardware         |
+---------------------------+
```

---

### Erklärung der Schichten

- **Anwendungen**  
  - Programme, die vom Benutzer gestartet werden  
  - Kommunizieren über Systemaufrufe mit dem Kernel  

- **VFS (Virtual File System), Systemaufrufe**  
  - Schnittstelle zwischen Programmen und Kernel  
  - Einheitlicher Zugriff auf unterschiedliche Dateisysteme  

- **IPC (Interprozesskommunikation), Dateisystem**  
  - Austausch von Daten zwischen Prozessen  
  - Organisation und Verwaltung von Dateien  

- **Scheduler, Virtual Memory**  
  - Scheduler: steuert, welcher Prozess wann Rechenzeit bekommt  
  - Virtual Memory: abstrahiert physischen Speicher, ermöglicht mehr Speicherplatz als physisch vorhanden  

- **Geräte-Treiber, Dispatcher**  
  - Treiber: steuern Hardware (z. B. Tastatur, Grafikkarte)  
  - Dispatcher: verwaltet Abläufe im Kernel  

- **Hardware**  
  - Physische Geräte: CPU, RAM, Festplatten, Ein-/Ausgabe-Geräte  
---
## Microkernel

### Definition
Ein **Microkernel** erfüllt nur die **grundlegenden Funktionen** eines Betriebssystems.  
Dazu gehören:
- **Grundlegende Interprozesskommunikation (IPC)**  
- **Speicherverwaltung**  
- **Prozessverwaltung**  

---

### Vorteile
- Funktionen sind **leicht austauschbar**  
- Absturz einzelner Komponenten ist **unkritisch** (das System bleibt stabil)  

---

### Nachteile
- Langsamer durch **erhöhten Rechenaufwand**  
- Aufwändiger **Sync der User-Prozesse** notwendig  
- **Ein- und Ausgaben müssen zusätzlich abgesichert** werden  
---
## Microkernel – Schichtenmodell

### Diagramm

```
+---------------------------+
|       Anwendungen         |
+---------------------------+
|  Anwendungs-IPC | UNIX-   |
|     Server      | Treiber |
|                 | Dateisy.|
+---------------------------+
| Basic IPC, Virtual Memory,|
|        Scheduling         |
+---------------------------+
|          Hardware         |
+---------------------------+
```

---

### Erklärung der Schichten

- **Anwendungen**  
  - Laufen im Benutzer-Modus  
  - Kommunizieren mit Kernel-Komponenten über IPC  

- **Anwendungs-IPC, UNIX-Server, Gerätetreiber, Dateisystem**  
  - Liegen im **User-Modus**, nicht im Kernel  
  - Sorgen für Modularität und Stabilität: Absturz eines Treibers legt nicht das ganze System lahm  

- **Basic IPC, Virtual Memory, Scheduling**  
  - Kernfunktionen, die direkt im Microkernel implementiert sind  
  - Minimalistisch: nur das absolut Notwendige (Kommunikation, Speicher, Prozesssteuerung)  

- **Hardware**  
  - Physische Geräte (CPU, RAM, Festplatten, Ein-/Ausgabe-Geräte)  

---
## Hybridkernel

### Definition
Ein **Hybridkernel** ist ein **Kompromiss** zwischen Monolithischem Kernel und Microkernel.  
- Nicht alle Komponenten sind im Kernel integriert  
- Teile laufen im Kernelmodus, andere im Usermodus  

---

### Vorteile
- Weniger fehleranfällig als ein **monolithischer Kernel**  
- Weniger Rechenaufwand als ein **Microkernel**  

---

### Beispiel
- **Windows NT 3.1 – Windows 11**
---
## Hybridkernel – Schichtenmodell

### Diagramm

```
+---------------------------+
|       Anwendungen         |
+---------------------------+
|   Dateisystem | UNIX-     |
|     Server    |           |
+---------------------------+
| Anwendungs-IPC | Geräte-  |
|                | Treiber  |
+---------------------------+
| Basic IPC, Virtual Memory,|
|        Scheduling         |
+---------------------------+
|          Hardware         |
+---------------------------+
```

---

### Erklärung der Schichten

- **Anwendungen**  
  - Benutzerprogramme, laufen im User-Modus  

- **Dateisystem, UNIX-Server**  
  - Einige Komponenten liegen im **User-Modus**  
  - Sorgen für bessere Stabilität als beim Monolithischen Kernel  

- **Anwendungs-IPC, Gerätetreiber**  
  - Teils im **Kernel-Modus**, teils im **User-Modus**  
  - Balance: mehr Performance als beim Microkernel, aber weniger Fehleranfälligkeit als beim Monolithischen  

- **Basic IPC, Virtual Memory, Scheduling**  
  - Kernfunktionen, die im Kernel-Modus laufen  
  - Sorgen für Prozesssteuerung, Speicherverwaltung und Grundkommunikation  

- **Hardware**  
  - Physische Geräte wie CPU, RAM, Festplatten, Ein-/Ausgabe-Geräte  

---

<details style="margin-top: 2em;">
<summary style="font-size: 0.9em; color: #888;">Metadaten anzeigen</summary>
<p style="font-size: 0.85em; color: grey;">
Teil der FIAE-Umschulung (2025-2027) am BFW Muehlenbeck.<br>
Diese Mitschrift entstand im Unterricht am 18.09.2025 mit SLE.<br>
Sie basiert auf gemeinsam erarbeiteten Inhalten und ergänzenden Übungsbeispielen vom 18.09.2025.<br><br>
Die Version wurde inhaltlich überarbeitet, strukturell optimiert und technisch ergänzt,<br>
um Lernerfolg, Prüfungsrelevanz und Nachvollziehbarkeit zu fördern.<br><br>
Öffentlich dokumentiert zur Wiederholung, Prüfungsvorbereitung und als Orientierungshilfe für Dritte.<br><br>
Quelle: Eigene Mitschrift & Unterrichtsinhalte<br>
Autor: Sean Conroy<br>
Lizenz: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a>
</p>
</details>
